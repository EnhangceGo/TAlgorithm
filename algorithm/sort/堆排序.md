# 堆排序算法原理

堆排序是一种高效的排序算法，它基于二叉堆数据结构实现。堆排序的时间复杂度为 O(n log n)，其中 n 是待排序元素的个数。下面我们来详细介绍一下堆排序算法的原理和步骤。

## 1. 建立堆

堆排序的第一步是建立堆。堆是一种完全二叉树，分为最大堆和最小堆两种。最大堆的每个父节点都比它的子节点大，最小堆的每个父节点都比它的子节点小。在堆排序中，我们一般使用最大堆。

我们可以从最后一个非叶子节点开始，依次将每个节点和它的子树调整为最大堆。这样可以保证每个节点都比它的子节点大。

具体步骤如下：

- 从最后一个非叶子节点开始，依次将每个节点和它的子树调整为最大堆。
- 依次向上调整每个节点，直到根节点为止。

下面是建立堆的示意图：

```markdown
         4                    9
       /   \                /   \
      1     3    =>        1     4
     / \   / \            / \   / \
    2   6 8   5          2   6 8   5


```

## 2. 排序

排序过程就是将堆中的元素依次取出来，放到数组中，并重新调整堆，保持堆的性质。

具体步骤如下：

- 将堆顶元素和堆底元素交换位置，将堆底元素作为已排序区间的一部分。
- 调整堆，保持堆的性质。
- 重复以上两个步骤，直到堆中的元素都被取出，排序完成。

```makefile
输入: 4 10 3 5 1

     4
    / \
  10   3
 / \
5   1

建立最大堆：

     10
    / \
   5   3
  / \
 4   1

堆顶元素为最大值，与最后一个元素交换位置：

     1
    / \
   5   3
  / 
 4   

     10
    / \
   4   3
  / 
 1   

重复建立最大堆和交换操作，直到排序完成：

     1
    / \
   4   3
  / 
 5   

     4
    / \
   1   3
  / 
 5   

     3
    / \
   1   4
  / 
 5   

     1
    / \
   3   4
  / 
 5   

     1
    / \
   3   4
  / 
 5   

输出: 1 3 4 5 10

```





## go实现

```go
package main

import "fmt"

func heapSort(arr []int) {
    n := len(arr)

    // 从最后一个非叶子节点开始，构建最大堆
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    // 从堆底开始取出元素，并重新调整堆
    for i := n-1; i >= 0; i-- {
        // 将堆顶元素和堆底元素交换
        arr[0], arr[i] = arr[i], arr[0]

        // 调整堆，保持最大堆的性质
        heapify(arr, i, 0)
    }
}

func heapify(arr []int, n, i int) {
    // 初始化最大值的位置和左右子节点的位置
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    // 找到最大值的位置
    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    // 如果最大值不是父节点，则交换位置，并递归调整子树
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func main() {
    arr := []int{4, 1, 3, 2, 6, 8, 5}
    heapSort(arr)
    fmt.Println(arr) // 输出 [1 2 3 4 5 6 8]
}

```

在这个示例代码中，我们首先使用 `heapify` 函数构建最大堆，然后使用堆排序算法将数组进行排序。`heapify` 函数用于调整一个节点及其子节点，使得它们满足最大堆的性质。堆排序算法使用一个循环，每次从堆底取出一个元素，放到已排序区间的末尾，并重新调整堆，直到堆中的元素都被取出。最后，堆排序算法返回已排序的数组。

# 算法效率对比

堆排序的时间复杂度为 O(n log n)，其中 n 是待排序元素的个数。堆排序的最坏时间复杂度和平均时间复杂度都是 O(n log n)，因此它是一种非常高效的排序算法。

与其他排序算法相比，堆排序的主要优点是不需要额外的空间，空间复杂度为 O(1)。而且它的平均时间复杂度比较稳定，在大多数情况下都能保持 O(n log n) 的时间复杂度。相对于快速排序，堆排序在最坏情况下的时间复杂度要略高一些，但是堆排序不会受到输入数据的影响，它在任何情况下的时间复杂度都是 O(n log n)。而快速排序在某些情况下会退化为 O(n^2) 的时间复杂度。

相对于归并排序，堆排序不需要额外的空间，而归并排序需要额外的 O(n) 空间来存储中间结果。因此，在空间受限的情况下，堆排序是更好的选择。

因此，堆排序算法是一种高效、稳定、不会受到输入数据影响的排序算法。它的主要缺点是实现起来比较复杂，代码难以理解。