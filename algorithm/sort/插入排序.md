##  插入排序算法原理

插入排序是一种简单直观的排序算法，它的基本思想是将一个无序的数列逐步构建成一个有序的数列。插入排序的实现方式是将一个待排序的数列分为两个部分：已排序部分和未排序部分。初始时已排序部分只包含一个元素，即数列的第一个元素；未排序部分包含除第一个元素以外的其他所有元素。每次从未排序部分中取出一个元素插入到已排序部分的正确位置上，直到所有元素都插入到已排序部分中，排序完成。

具体实现过程如下：

1. 将待排序的数列分为已排序部分和未排序部分，初始时已排序部分只包含数列的第一个元素，未排序部分包含数列的其余元素；
2. 从未排序部分中取出第一个元素，将它插入到已排序部分的正确位置上；
3. 重复步骤 2，直到未排序部分中的所有元素都被插入到已排序部分中。

下面通过一个示例来说明插入排序的具体实现过程。假设待排序的数列为：`5 3 8 6 4`。

1. 初始时已排序部分只包含数列的第一个元素 `5`，未排序部分包含数列的其余元素 `3 8 6 4`。
2. 从未排序部分中取出第一个元素 `3`，将它插入到已排序部分的正确位置上。此时已排序部分为 `3 5`，未排序部分为 `8 6 4`。
3. 从未排序部分中取出第一个元素 `8`，将它插入到已排序部分的正确位置上。此时已排序部分为 `3 5 8`，未排序部分为 `6 4`。
4. 从未排序部分中取出第一个元素 `6`，将它插入到已排序部分的正确位置上。此时已排序部分为 `3 5 6 8`，未排序部分为 `4`。
5. 从未排序部分中取出第一个元素 `4`，将它插入到已排序部分的正确位置上。此时已排序部分为 `3 4 5 6 8`，未排序部分为空。



## 图示

整个过程的示意图如下所示：

```
初始状态：
5 3 8 6 4
已排序部分：5
未排序部分：3 8 6 4

第一次插入排序：
3 5 8 6 4
已排序部分：3 5
未排序部分：8 6 4

第二次插入排序：
3 5 8 6 4
已排序部分：3 5 8
未排序部分：6 4

第三次插入排序：
3 5 6 8 4
已排序部分：3 5 6 8
未排序部分：4

第四次插入排序：
3 4 5 6 8
已排序部分：3 4 5 6 8
未排序部分：空

```

下面是一个简单的 Markdown 图展示，展示了一个示意图：

```go
A
/
B C
/ \
D E F
```

## Go语言实现 

下面是用 Go 语言实现插入排序的代码：

```go
func insertionSort(arr []int) {
    for i := 1; i < len(arr); i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
insertionSort(arr)
fmt.Println(arr)
```

该代码使用了一个外层循环和一个内层循环，其中外层循环将数组元素一个一个地插入到已排序的序列中，内层循环则用来查找正确的插入位置。

具体来说，外层循环遍历数组中的每一个元素（从第二个元素开始），内层循环则将该元素依次与已排序的元素比较，找到正确的插入位置，将其插入到已排序的序列中。

这里使用了一个`key`变量来保存当前正在排序的元素的值，然后通过内层循环依次将已排序的元素向后移动，直到找到插入位置，然后将`key`插入到该位置。

需要注意的是，在 Go 中，切片是传递的引用，因此对切片的排序会直接改变原始切片的顺序，不需要返回排序后的结果。

## 算法效率对比

插入排序的时间复杂度是 `$O(n^2)$`，空间复杂度是` $O(1)$`。当待排序的数列已经有序时，插入排序的时间复杂度是` $O(n)$`，是所有排序算法中最快的。

下面是插入排序与其他排序算法的时间复杂度对比图：

| 排序算法 | 时间复杂度（最坏情况） | 时间复杂度（平均情况） |  空间复杂度   | 是否稳定 |
| :------: | :--------------------: | :--------------------: | :-----------: | :------: |
| 冒泡排序 |       `$O(n^2)$`       |       `$O(n^2)$`       |   `$O(1)$`    |    是    |
| 选择排序 |       `$O(n^2)$`       |       `$O(n^2)$`       |   `$O(1)$`    |    否    |
| 插入排序 |       `$O(n^2)$`       |       `$O(n^2)$`       |   `$O(1)$`    |    是    |
| 快速排序 |       `$O(n^2)$`       |     `$O(n\log n)$`     | `$O(\log n)$` |    否    |
| 归并排序 |     `$O(n\log n)$`     |     `$O(n\log n)$`     |   `$O(n)$`    |    是    |
|  堆排序  |     `$O(n\log n)$`     |     `$O(n\log n)$`     |   `$O(1)$`    |    否    |



## 总结

插入排序是一种简单、直观、易于理解和实现的排序算法，适用于数据量较小、有序性较高的数据排序。但是在数据量较大、无序性较高的情况下，插入排序的效率会变得很低，不如其他高级排序算法。因此，在实际应用中需要根据具体情况选择合适的排序算法。