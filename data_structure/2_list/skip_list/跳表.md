

# Skip List 数据结构详解

Skip List 是一种高效的数据结构，可以在 O(log n) 的时间复杂度内完成插入、查找和删除操作。它是一种多层的链表结构，每一层中的节点都是按照 key 的大小排列的。Skip List 可以作为一种高效的数据结构应用在各种需要高效查找的场景中。本文将介绍 Skip List 的基本概念、特点、插入、查找、删除操作及其 Go 语言实现。

## Skip List 的基本概念

Skip List 由 W. Pugh 在 1990 年提出，是一种多层的链表结构。每一层中的节点都是按照 key 的大小排列的。Skip List 的每一层都是一个链表，最底层的链表包含所有的节点。每一层的节点数量是前一层的节点数量的一半。这个特性使得 Skip List 的查询效率接近于二分查找，但是 Skip List 的插入、删除操作比二分查找更高效。

每一层的头节点称为头指针，尾节点称为尾指针。每一个节点包含三个字段：

- key：节点的关键字，用于排序。
- value：节点的值。
- next：一个指针数组，用于指向每一层中的下一个节点。

Skip List 通过多层链表的形式，将查找和插入操作的时间复杂度降为 O(log n)，并且实现起来比较简单。

## Skip List 的特点

Skip List 的主要特点包括：

1. 多层结构：Skip List 的每一层都是一个有序的链表结构，每一层中的节点数量是前一层的节点数量的一半。Skip List 可以根据具体的需求决定层数，从而达到更好的效果。
2. 高效的查找操作：Skip List 的查找操作的时间复杂度为 O(log n)，接近于二分查找。Skip List 通过多层链表的形式，将查找操作的时间复杂度降为 O(log n)。
3. 高效的插入、删除操作：Skip List 的插入、删除操作的时间复杂度为 O(log n)，比二叉树的插入、删除操作更高效。
4. 空间占用小：Skip List 的空间占用与链表相当，不会像平衡树一样因为需要维护平衡而浪费大量的空间。

## Skip List 的插入操作

在 Skip List 中插入一个节点时，首先需要确定该节点在每一层的位置。为了确定节点在每一层的位置，我们可以通过伪随机数生成器来生成节点的层数。假设 Skip List 的最大层数为 k，那么生成节点的层数的方法是，在每一层都随机生成一个数，如果这个数小于某个阈值，则节点就在这一层中。阈值通常设置为 0.5，这样节点在下一层的概率是上一层的概率的一半。

插入节点时，首先需要查找插入位置。从最高层开始，从左到右依次遍历每一层，找到在该层中的插入位置。对于每一层，我们都可以使用一个指针来记录当前节点的位置，从而实现查找和插入操作的高效性。在查找插入位置的过程中，需要记录每一层的前驱节点，以便在插入节点时链接新的节点。

插入节点后，需要按照概率决定是否在更高的层插入节点。如果决定在更高的层插入节点，则需要重新生成一个层数，并且将新生成的层数与之前的层之间链接起来。这个过程可以重复执行，直到新生成的层数为 1 或者概率决定不再继续插入为止。

下面是 Skip List 插入操作的示意图：

```markdown
+--------+             +--------+
| Header |------------>| Header |
+--------+             +--------+
|   7    |------->     |   7    |-------> 
+--------+             +--------+
|   5    |------->     |   5    |-------> 
+--------+             +--------+
|   3    |------->     |   3    |-------> 
+--------+             +--------+
|   1    |------->     |   1    |-------> 
+--------+             +--------+

插入节点 4

+--------+             +--------+
| Header |------------>| Header |
+--------+             +--------+
|   7    |------->     |   7    |-------> 
+--------+             +--------+
|   5    |------->     |   5    |-------> 
+--------+             +--------+
|   4    |------->     |   4    |-------> 
+--------+             +--------+
|   3    |------->     |   3    |-------> 
+--------+             +--------+
|   1    |------->     |   1    |-------> 
+--------+             +--------+

```



## Skip List 的查找操作

在 Skip List 中查找一个节点时，同样需要从最高层开始，从左到右依次遍历每一层。对于每一层，我们可以使用一个指针来记录当前节点的位置，从而实现查找操作的高效性。

当找到目标节点时，返回该节点的值即可。如果没有找到目标节点，则返回空。

下面是 Skip List 查找操作的示意图：

```markdown
+--------+
| Header |---------------------> 
+--------+
|   7    |------->     +--------+
+--------+             |   7    |-------> 
|   5    |------->     +--------+
+--------+             |   5    |-------> 
|   4    |------->     +--------+
+--------+             |   4    |-------> 
|   3    |------->     +--------+
+--------+             |   3    |-------> 
|   1    |------->     +--------+
+--------+             |   1    |-------> 
                       +--------+

查找值为 4 的节点

+--------+
| Header |---------------------> 
+--------+
|   7    |------->     +--------+
+--------+             |   7    |-------> 
|   5    |------->     +--------+
+--------+             |   5    |-------> 
|   4    |------->     +--------+
|   *    |------->     |   4    |------->

```



## Skip List 的删除操作

在 Skip List 中删除一个节点时，需要从最高层开始，从左到右依次遍历每一层，找到待删除节点以及每一层中的前驱节点。在删除节点时，需要断开待删除节点与前驱节点的链接，并将前驱节点与待删除节点的下一个节点相连。

下面是 Skip List 删除操作的示意图：

```markdown
+--------+
| Header |---------------------> 
+--------+
|   7    |------->     +--------+
+--------+             |   7    |-------> 
|   5    |------->     +--------+
+--------+             |   5    |-------> 
|   4    |------->     +--------+
|   *    |------->     |   4    |-------> 
|   3    |------->     +--------+
+--------+             |   3    |-------> 
|   1    |------->     +--------+
+--------+             |   1    |-------> 

删除节点 4

+--------+
| Header |---------------------> 
+--------+
|   7    |------->     +--------+
+--------+             |   7    |-------> 
|   5    |------->     +--------+
+--------+             |   5    |-------> 
|   *    |------->     |   3    |-------> 
|   3    |------->     +--------+
+--------+             |   1    |-------> 
|   1    |------->     +--------+
+--------+             

```



## 实现跳表

```go
package main

import (
	"fmt"
	"math/rand"
)

const (
	maxLevel = 16  // SkipList 的最大层数
	p        = 0.5 // 节点向上提升一层的概率
)

type node struct {
	key     int         // 节点的 key
	value   interface{} // 节点的 value
	forward []*node     // 节点每一层的后继指针
}

type SkipList struct {
	head   *node // SkipList 的头节点
	level  int   // SkipList 的层数
	length int   // SkipList 的长度
}

// newNode 创建一个新节点
func newNode(key int, value interface{}, level int) *node {
	return &node{
		key:     key,
		value:   value,
		forward: make([]*node, level),
	}
}

// NewSkipList 创建一个新的 SkipList
func NewSkipList() *SkipList {
	return &SkipList{
		head:   newNode(0, nil, maxLevel),
		level:  1,
		length: 0,
	}
}

// randomLevel 随机生成节点的层数
func randomLevel() int {
	level := 1
	for rand.Float64() < p && level < maxLevel {
		level++
	}
	return level
}

// Insert 将一个节点插入到 SkipList 中
func (sl *SkipList) Insert(key int, value interface{}) {
	update := make([]*node, maxLevel)
	x := sl.head
	// 从高到低遍历每一层，找到要插入的位置
	for i := sl.level - 1; i >= 0; i-- {
		for x.forward[i] != nil && x.forward[i].key < key {
			x = x.forward[i]
		}
		update[i] = x
	}
	// 如果 key 已经存在，更新对应的 value
	x = x.forward[0]
	if x != nil && x.key == key {
		x.value = value
	} else {
		// 随机生成节点的层数
		level := randomLevel()
		if level > sl.level {
			// 如果节点的层数大于 SkipList 的层数，更新 SkipList 的层数
			for i := sl.level; i < level; i++ {
				update[i] = sl.head
			}
			sl.level = level
		}
		// 创建新节点
		x = newNode(key, value, level)
		// 更新每一层的后继指针
		for i := 0; i < level; i++ {
			x.forward[i] = update[i].forward[i]
			update[i].forward[i] = x
		}
		sl.length++
	}
}

// Delete 从 SkipList 中删除一个节点
func (sl *SkipList) Delete(key int) {
	update := make([]*node, maxLevel)
	x := sl.head
	// 从高到低遍历每一层，找到要删除的节点
	for i := sl.level - 1; i >= 0; i-- {
		for x.forward[i] != nil && x.forward[i].key < key {
			x = x.forward[i]
		}
		// 更新 update 数组，记录每一层需要更新的节点
		update[i] = x
	}
	x = x.forward[0]
	if x != nil && x.key == key {
		// 如果找到了要删除的节点，更新每一层的后继指针
		for i := 0; i < sl.level; i++ {
			if update[i].forward[i] != x {
				break
			}
			update[i].forward[i] = x.forward[i]
		}
		sl.length--
		// 如果删除了最高层的节点，更新 SkipList 的层数
		for sl.level > 1 && sl.head.forward[sl.level-1] == nil {
			sl.level--
		}
	}
}

// Search 在 SkipList 中查找一个节点
func (sl *SkipList) Search(key int) interface{} {
	x := sl.head
	// 从高到低遍历每一层，找到要查找的节点
	for i := sl.level - 1; i >= 0; i-- {
		for x.forward[i] != nil && x.forward[i].key < key {
			x = x.forward[i]
		}
	}
	x = x.forward[0]
	if x != nil && x.key == key {
		// 如果找到了要查找的节点，返回节点的 value
		return x.value
	}
	// 没有找到要查找的节点，返回 nil
	return nil
}
func main() {
	sl := NewSkipList()
	sl.Insert(3, "value1")
	sl.Insert(1, "value2")
	sl.Insert(2, "value3")
	fmt.Println(sl.Search(1)) // value2
	fmt.Println(sl.Search(2)) // value3
	fmt.Println(sl.Search(3)) // value1

	sl.Delete(2)

	fmt.Println(sl.Search(2)) // nil
}

```



### 高级应用

Skip List 不仅可以用于基本的插入、删除和查找操作，还可以用于许多高级应用。下面我们将介绍其中的一些应用。

#### 并发 Skip List

在并发环境中，多个线程同时对同一个 Skip List 进行操作可能会导致数据不一致的问题。为了解决这个问题，可以实现一种支持并发操作的 Skip List。

具体来说，可以使用读写锁来保护 Skip List 中的操作。对于读取操作（如查找元素），可以使用共享锁来允许多个线程同时访问同一个节点；对于修改操作（如插入和删除元素），必须使用排他锁来确保同一时间只有一个线程能够访问节点。

除了使用锁来控制并发访问，还可以使用乐观锁或者无锁算法来实现并发 Skip List。在这种方法中，每个节点都包含一个版本号（version number），每次修改节点时都会增加其版本号。当多个线程同时访问同一个节点时，只有一个线程能够成功修改节点，其他线程会重新尝试操作。

#### 跳表索引

Skip List 通常用于实现动态数据集合，其中元素的插入和删除比较频繁。在某些情况下，我们可能需要使用 Skip List 来实现静态数据集合，其中元素的数量比较固定且不会经常改变。在这种情况下，可以使用 Skip List 的索引结构来进行快速查找。

具体来说，我们可以在 Skip List 中的每个节点中维护一个指向下一个索引节点的指针。在每个索引节点上，我们维护一个指向下一个更高层的索引节点的指针。这样，我们就可以通过索引节点快速定位到某个元素所在的区间，然后在该区间内使用 Skip List 进行查找。

#### 分布式 Skip List

在分布式环境中，我们需要将 Skip List 进行分布式部署，以便多个节点之间共享数据。在这种情况下，我们需要使用一些特殊的技术来解决数据同步和一致性的问题。

具体来说，我们可以使用一致性哈希（Consistent Hashing）来将数据分散到多个节点上。每个节点负责存储一定范围的数据，同时维护与其他节点之间的路由信息。当节点之间需要进行数据同步时，可以使用分布式事务来确保数据的一致性。

另外，我们还可以使用基于 Paxos 算法或者 Raft 算法的分布式协议来实现 Skip List 的分布式部署。在这种方法中，每个节点

都拥有一份完整的 Skip List 数据，节点之间通过消息传递来实现数据同步和一致性。

#### 带权 Skip List

在一些应用中，元素可能具有不同的权重，例如搜索引擎中的网页排名。为了支持带权元素的插入和查找，可以使用带权 Skip List。

在带权 Skip List 中，每个节点不仅包含元素的值和指向下一个节点的指针，还包含一个权重值。在进行元素查找时，我们需要计算每个节点的累积权重，然后根据随机数生成器产生的随机数来决定是否跳过当前节点。具体来说，假设当前节点的权重为 $w_i$，下一个节点的权重为 $w_{i+1}$，则我们可以计算出一个跳过当前节点的概率 $p_i$：

$$p_i = \frac{w_i}{w_i + w_{i+1}}$$

然后我们根据随机数 $r$ 与概率 $p_i$ 的大小关系来判断是否跳过当前节点。如果 $r < p_i$，则跳过当前节点，否则继续向下遍历。

在插入带权元素时，我们需要根据元素的权重来决定其在 Skip List 中出现的次数。具体来说，假设插入一个元素 $x$，其权重为 $w_x$，则我们需要在每层中都插入 $w_x$ 个节点，每个节点的值都为 $x$，并且节点的权重值都为 $w_x$。

#### 基于 Skip List 的其他数据结构

Skip List 还可以作为其他数据结构的基础，例如有序集合、有序映射、有序队列等。具体来说，我们可以使用 Skip List 来维护一个有序集合或者有序映射，其中元素按照键值的大小进行排序。同时，我们还可以使用 Skip List 来实现一个有序队列，其中元素按照优先级进行排序。

### 总结

SkipList 是一种高效的动态数据结构，它可以实现快速插入、删除和查找节点。SkipList 的插入、删除和查找操作的时间复杂度均为 O(log n)，在实际应用中效果良好。

SkipList 通过在节点中增加多个后继指针和随机化来实现高效的查找操作。每个节点中的后继指针指向下一层和右侧的节点，这样就可以跳过一些节点，提高查找效率。而随机化则可以保证 SkipList 的平衡性，避免因为数据分布不均匀而导致的性能下降。

在使用 SkipList 时，我们可以根据实际情况调整 SkipList 的层数和节点数量，以达到最优的性能。

## 参考

[1] ： [skiplist](https://www.jianshu.com/p/9d8296562806)