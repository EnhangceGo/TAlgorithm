# 堆（Heap）详解

堆是一种重要的数据结构，通常用来实现优先队列。本文将详细介绍堆的概念、二叉堆和斐波那契堆的实现、堆的操作以及应用场景。

## 概述

堆是一种树形数据结构，它通常有两种实现方式：二叉堆和斐波那契堆。堆有以下特点：

- 堆是一个完全二叉树，即除了最后一层外，其他层的节点数都是满的，最后一层从左往右填满。
- 堆分为两种类型：最大堆和最小堆。
- 最大堆：每个节点的值都大于或等于其子节点的值。
- 最小堆：每个节点的值都小于或等于其子节点的值。
- 堆的根节点总是堆中的最大值或最小值。

## 二叉堆

二叉堆是一种基于完全二叉树的堆实现，它分为两种类型：最大堆和最小堆。二叉堆的父节点和子节点之间有以下关系：

- 父节点的值总是大于或等于其子节点的值（最大堆）。
- 父节点的值总是小于或等于其子节点的值（最小堆）。

因此，二叉堆的根节点总是堆中的最大值或最小值。

### 最大堆的实现

二叉堆最常见的实现方式是数组。我们将二叉堆按照从上到下、从左到右的顺序排列在数组中，那么堆中的节点就对应数组中的元素。如下图所示，二叉堆的根节点对应数组的第一个元素，第二层的两个子节点对应数组的第二个和第三个元素，以此类推。

```markdown
           10
          /  \
         5    8
        / \  / \
       2  4 6   7
```

将上面的堆按照数组顺序排列，得到如下数组：

```markd
[10, 5, 8, 2, 4, 6, 7]
```

数组中第一个元素总是堆的根节点，所以可以直接访问堆的最大值。二叉堆的插入和删除操作都可以在数组上进行，操作过程中需要保证堆的性质不被破坏。

#### 插入操作

插入操作将一个元素添加到堆中。它的实现过程如下：

1. 将元素添加到堆的最后一个位置。
2. 如果新节点的值大于其父节点的值，交换新节点和父节点的位置，
3. 重复步骤2，直到新节点的值小于或等于其父节点的值。

```markdown
           10
          /  \
         5    8
        / \  / \
       2  4 6   7
      /
     9
```

接下来，将9和其父节点5进行比较。由于9大于5，需要将它们的位置交换，得到以下堆：

```markdown
           10
          /  \
         9    8
        / \  / \
       2  4 6   7
      /
     5

```

现在，我们需要再次比较9和其父节点10。由于9小于10，插入操作结束。

插入操作的时间复杂度为 `$O(log n)$`，其中n为堆中元素的个数。

#### 删除操作

删除操作将堆中的最大元素（或最小元素）删除，并将堆重新维护为一个堆。它的实现过程如下：

1. 将根节点（即最大元素或最小元素）从堆中删除。
2. 将堆的最后一个元素移动到根节点的位置。
3. 比较新的根节点和其子节点的值，如果新的根节点的值小于其子节点的值，交换根节点和最大（或最小）的子节点的位置，然后重复步骤3，直到新的根节点的值大于或等于其子节点的值。

例如，我们要从上面的最大堆中删除根节点10。首先将10从堆中删除，得到以下堆：

```markdown
           9
          /  \
         5    8
        / \  / \
       2  4 6   7

```

接下来，将堆的最后一个元素7移动到根节点的位置，得到以下堆：

```markdown
           7
          /  \
         5    8
        / \  / 
       2  4 6   

```

现在，我们需要比较新的根节点7和其子节点5和8的值。由于7小于8，需要将它们的位置交换，得到以下堆：

```markdown
           8
          /  \
         5    7
        / \   
       2  4 6   

```

现在，我们需要再次比较新的根节点8和其子节点5和7的值。由于8大于5和7，删除操作结束。

删除操作的时间复杂度为 `$O(log n)$`，其中n为堆中元素的个数。

### 斐波那契堆

斐波那契堆是一种基于多叉树的堆实现，它采用了一些优化方法，使得堆的插入、删除、合并等操作的时间复杂度更低。斐波那契堆的主要优势在于它的合并操作的时间复杂度为 $O(1)$，这意味着可以非常高效地合并两个堆。

斐波那契堆的基本结构是由多个小树组成的森林，每个小树都遵循最小堆性质。这些小树之间存在一些限制条件，包括：

1. 每个小树的根节点都保存着一个元素。
2. 每个小树的根节点的所有子节点都不超过` $D$` 个，其中 `$D$` 是一个固定的常数，通常取 `$D=2$`。
3. 每个小树都满足最小堆性质，即每个节点的值都不大于其子节点的值。
4. 每个小树的根节点都保存着其子节点中最小的元素。

由于斐波那契堆是由多个小树组成的，因此可以使用一个双向循环链表来维护这些小树。双向循环链表中每个节点保存着一个小树的根节点，以及其在链表中的前驱和后继节点。

以下是一个包含三个小树的斐波那契堆的示意图：

```markdown
           6            2            3
          / \          / \          / \
         8   10       4   5        7   9
```

在斐波那契堆中，插入操作的实现过程如下：

1. 将要插入的元素包装成一个单节点的小树。
2. 将这个小树插入到堆中。
3. 如果新插入的节点的值比堆中最小节点的值还要小，将堆的最小节点更新为新插入的节点。

例如，我们要在上面的斐波那契堆中插入元素1。首先将1包装成一个单节点的小树，得到以下小树：

```markdown
           1

```

接下来，将这个小树插入到堆中，得到以下斐波那契堆：

```markdown
           1            6            2            3
                        / \          / \          / \
                       8   10       4   5        7   9
```

现在，我们需要将堆的最小节点更新为1，得到以下堆：

```markdown
           1            6            2            3
                        / \          / \          / \
                       8   10       4   5        7   9
```

插入操作的时间复杂度为 `$O(1)$`。

删除操作的实现过程如下：

1.找到要删除的节点，并将其从堆中删除。

2. 将被删除节点的所有子节点都插入到堆中。
3. 对每个新插入的子节点，如果其父节点已被删除，则将其父节点标记为非根节点，并将其插入到堆的根链表中。

例如，我们要在上面的斐波那契堆中删除节点2。首先找到要删除的节点，将其从堆中删除，并将其所有子节点都插入到堆中。得到以下堆：

```markdown
           6            4            3
          / \          / \          / \
         8   10       5   7        9   2
```

现在，对于新插入的子节点，如果其父节点已被删除，则将其父节点标记为非根节点，并将其插入到堆的根链表中。对于节点2，其父节点6仍然存在，因此不需要将其插入到堆的根链表中。对于节点5和节点7，它们的父节点2已经被删除，因此需要将其插入到堆的根链表中。得到以下堆：

```markdown
           6            4            3
          / \          / \          / \
         8   10       5   7        9
                                / \
                               2   5
```

删除操作的时间复杂度为` $O(\log n)$`。

斐波那契堆的合并操作是斐波那契堆的一个重要特点，它能够将两个斐波那契堆合并为一个新的斐波那契堆。合并操作的实现过程如下：

1. 将两个堆的根链表合并为一个新的根链表。
2. 找到新的根链表中最小的节点，并将其设为新堆的最小节点。
3. 根据新堆的最小节点，将新的根链表分裂成 `$D$ `个小树。
4. 将这些小树插入到堆中。

例如，我们要将以下两个斐波那契堆合并为一个新的斐波那契堆：

```markdown
           6            4
          / \          / \
         8   10       5   7
```

```markdown
           2            3
          / \          / \
         7   9        11  13
                     /
                    12
```



首先将两个堆的根链表合并为一个新的根链表，得到以下根链表：

```markdown
           2            6            4            3
          / \          / \          / \          / \
         7   9       8   10       5   7       11  13
                     /                       /
                    2                       12
```

接下来，找到新的根链表中最小的节点，并将其设为新堆的最小节点。在本例中，最小节点为节点2。

根据新堆的最小节点，将新的根链表分裂成 `$D$ `个小树。在本例中，节点2是根节点，有两个子节点7和9，因此需要将根链表分裂成两个小树。

最后，将这些小树插入到堆中，得到以下新的斐波那契堆：

```markdown
           2            3            4
          / \          / \          / \
         7   9       11  13       5   7
                     / \               \
                    12  2               6
```

合并操作的时间复杂度为` $O(1)$`。

斐波那契堆的实现非常复杂，需要处理大量的指针和链表操作。但是，它的时间复杂度非常优秀，因此在一些需要高效数据结构的应用中得到了广泛的应用。例如，Prim算法和Dijkstra算法都可以使用斐波那契堆来实现。



## 高级应用

### 堆排序

堆排序是一种基于堆的排序算法。它的基本思想是将无序数组构建成一个堆，然后反复从堆顶取出最大元素并删除，最终得到一个有序数组。这个过程被称为堆排序。

```go
func HeapSort(a []int) {
    h := BuildHeap(a)
    for i := len(h.slice) - 1; i > 0; i-- {
        h.slice[0], h.slice[i] = h.slice[i], h.slice[0]
        h.down(0, i)
    }
}

```

堆排序的时间复杂度是O(n log n)，它是一种不稳定的排序算法。

### Top K 问题

Top K 问题是指从一个无序数组中选出前K个最大或最小的元素。它可以使用堆来解决。

我们维护一个大小为K的小根堆。对于数组中的每个元素，如果它比小根堆的堆顶元素大，就将堆顶元素弹出，并将该元素插入到堆中。这样，当我们处理完整个数组后，堆中的元素就是前K个最大的元素。

```go
func TopK(a []int, k int) []int {
    h := &Heap{slice: make([]int, k)}
    copy(h.slice, a[:k])
    BuildHeap(h.slice)
    for i := k; i < len(a); i++ {
        if a[i] > h.slice[0] {
            h.slice[0] = a[i]
            h.down(0, k)
        }
    }
    sort.Sort(sort.Reverse(sort.IntSlice(h.slice)))
    return h.slice
}

```

op K 问题的时间复杂度是O(n log k)。

### 合并 K 个有序数组

合并 K 个有序数组是一道经典的算法问题。我们可以使用堆来解决。

我们维护一个大小为K的小根堆。对于每个数组，我们将它的第一个元素插入到堆中。每次取出堆顶元素，并将该元素所在数组的下一个元素插入到堆中。重复这个过程，直到堆为空。这样，我们就可以得到一个有序数组。

```go
type Element struct {
    value int
    index int
}

type ElementHeap []*Element

func (h ElementHeap) Len() int {
    return len(h)
}

func (h ElementHeap) Less(i, j int) bool {
    return h[i].value < h[j].value
}

func (h ElementHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}

func (h *ElementHeap) Push(x interface{}) {
    *h = append(*h, x.(*Element))
}

func (h *ElementHeap) Pop() interface{} {
    n := len(*h)
    x := (*h)[n-1]
    *h = (*h)[:n-1]
    return x
}

func MergeKSortedArrays(a [][]int) []int {
    n := len(a)
    h := make(ElementHeap, 0, n)
    for i := 0; i < n; i++ {
        if len(a[i]) > 0 {
            e := &Element{value: a[i][0], index: 0}
            h = append(h, e)
        }
    }
    heap.Init(&h)
    res := make([]int, 0, n*n)
    for len(h) > 0 {
        e := heap.Pop(&h).(*Element)
        res = append(res, e.value)
        i := e.index
        if i+1 < len(a[e.index]) {
            e := &Element{value: a[e.index][i+1], index: e.index}
            heap.Push(&h, e)
        }
    }
    return res
}

```

合并 K 个有序数组的时间复杂度是O(n log k)，其中n是所有数组中元素的个数。

## 总结

堆是一种非常重要的数据结构。它不仅可以用来解决许多算法问题，而且还可以用来实现许多高级数据结构，如优先队列、哈希表等。堆有两种基本类型：大根堆和小根堆。它们在实现中非常相似，只是比较函数的返回值不同。

我们可以使用堆来解决一些非常经典的算法问题，如Top K问题、合并 K 个有序数组等。堆可以非常有效地处理这些问题，时间复杂度为O(n log k)。

当我们需要实现一个优先队列时，我们可以使用堆来实现。堆的优势在于它可以在O(log n)的时间内执行插入和删除操作。堆还可以用来实现许多高级数据结构，如哈希表、前缀树等。

最后，堆是一种非常重要的数据结构，它在算法和数据结构中发挥着重要的作用。我们可以使用堆来解决许多实际的问题，如Top K问题、合并 K 个有序数组等。

